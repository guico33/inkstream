import { Handler } from 'aws-lambda';
import {
  PollyClient,
  SynthesizeSpeechCommand,
  OutputFormat,
  Engine,
  VoiceId,
  LanguageCode,
} from '@aws-sdk/client-polly';

import { PutObjectCommand, S3Client } from '@aws-sdk/client-s3';
import { Readable } from 'stream';

// Helper function to convert stream to buffer
async function streamToBuffer(stream: Readable): Promise<Buffer> {
  return new Promise<Buffer>((resolve, reject) => {
    const chunks: Buffer[] = [];
    stream.on('data', (chunk) =>
      chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk))
    );
    stream.on('error', reject);
    stream.on('end', () => resolve(Buffer.concat(chunks)));
  });
}

// Initialize clients
const polly = new PollyClient({});
const s3 = new S3Client({});

interface ConvertToSpeechRequest {
  fileKey: string;
  formattedText?: string;
  translatedText?: string;
  targetLanguage?: string;
}

/**
 * Preprocesses text to remove Markdown formatting that would
 * affect the speech output quality when using Amazon Polly.
 */
function preprocessTextForSpeech(text: string): string {
  let processedText = text;

  // Replace Markdown headings with just the text
  // This removes heading markers like # ## ###, etc.
  processedText = processedText.replace(/^(#{1,6})\s+(.+?)$/gm, '$2');

  // Additional preprocessing for other Markdown elements
  // Remove bullet points
  processedText = processedText.replace(/^\s*[-*+]\s+/gm, '');
  // Remove numbered lists markers
  processedText = processedText.replace(/^\s*\d+\.\s+/gm, '');
  // Remove code block markers
  processedText = processedText.replace(/```[\s\S]*?```/g, '');
  // Remove inline code marks
  processedText = processedText.replace(/`([^`]+)`/g, '$1');

  console.log('Text preprocessed for Polly - removed Markdown formatting');
  return processedText;
}

// Voice mapping for different languages
const voiceMap: Record<
  string,
  { voiceId: VoiceId; languageCode: LanguageCode; supportsNeural: boolean }
> = {
  english: { voiceId: 'Joanna', languageCode: 'en-US', supportsNeural: true },
  french: { voiceId: 'Lea', languageCode: 'fr-FR', supportsNeural: true },
  spanish: { voiceId: 'Lupe', languageCode: 'es-US', supportsNeural: true },
  german: { voiceId: 'Vicki', languageCode: 'de-DE', supportsNeural: true },
  italian: { voiceId: 'Bianca', languageCode: 'it-IT', supportsNeural: true },
  portuguese: {
    voiceId: 'Camila',
    languageCode: 'pt-BR',
    supportsNeural: true,
  },
  japanese: { voiceId: 'Takumi', languageCode: 'ja-JP', supportsNeural: true },
  chinese: { voiceId: 'Zhiyu', languageCode: 'cmn-CN', supportsNeural: true },
  // Add more languages as needed
};

async function textToSpeech(
  text: string,
  language: string,
  fileKey: string
): Promise<string> {
  if (!text || text.trim() === '') {
    throw new Error('No text content to convert to speech');
  }

  // Normalize language name for lookup (lowercase)
  const normalizedLang = language.toLowerCase();

  // Get voice settings from the map, default to English if not found
  const voiceSettings = voiceMap[normalizedLang] || voiceMap.english;

  // Log selected voice
  console.log(`Using voice ${voiceSettings.voiceId} for language ${language}`);

  // Generate a unique S3 key for the audio file
  const audioFileKey = `speech/${
    fileKey.split('/').pop()?.split('.')[0] || 'audio'
  }-${Date.now()}.mp3`;

  try {
    // Preprocess text to handle Markdown and formatting characters
    const processedText = preprocessTextForSpeech(text);

    // Call Amazon Polly to synthesize speech
    const pollyResponse = await polly.send(
      new SynthesizeSpeechCommand({
        Text: processedText,
        OutputFormat: OutputFormat.MP3,
        VoiceId: voiceSettings.voiceId,
        LanguageCode: voiceSettings.languageCode,
        Engine: voiceSettings.supportsNeural ? Engine.NEURAL : Engine.STANDARD,
      })
    );

    // Upload the audio stream to S3
    if (!pollyResponse.AudioStream) {
      throw new Error('No audio stream generated by Polly');
    }

    const bucketName = process.env.BUCKET_NAME;
    if (!bucketName) {
      throw new Error('Missing BUCKET_NAME in environment variables');
    }

    // Convert the audio stream to a buffer
    const audioBuffer = await streamToBuffer(
      pollyResponse.AudioStream as Readable
    );

    await s3.send(
      new PutObjectCommand({
        Bucket: bucketName,
        Key: audioFileKey,
        Body: audioBuffer,
        ContentType: 'audio/mpeg',
      })
    );

    console.log(`Audio file saved to S3: ${audioFileKey}`);
    return audioFileKey;
  } catch (error) {
    console.error('Error converting text to speech:', error);
    throw new Error(
      `Failed to convert text to speech: ${
        error instanceof Error ? error.message : 'Unknown error'
      }`
    );
  }
}

export const handler: Handler = async (event: ConvertToSpeechRequest) => {
  console.log(
    'Convert to speech Lambda invoked with event:',
    JSON.stringify(event)
  );

  if (!event.fileKey) {
    throw new Error('Missing fileKey in event');
  }

  // Determine which text to use for speech
  let textToConvert: string;
  let language = 'english';

  if (event.translatedText && event.targetLanguage) {
    // Use translated text if available
    textToConvert = event.translatedText;
    language = event.targetLanguage;
  } else if (event.formattedText) {
    // Otherwise use formatted text
    textToConvert = event.formattedText;
  } else {
    throw new Error('No text found to convert to speech');
  }

  // Convert text to speech and get S3 location
  const audioFileKey = await textToSpeech(
    textToConvert,
    language,
    event.fileKey
  );

  // Keep all original properties and add our result
  // This ensures doTranslate, doSpeech and other properties remain at the root level
  return {
    ...event,
    audioFileKey,
  };
};
