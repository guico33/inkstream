import { Handler } from 'aws-lambda';
import {
  PollyClient,
  SynthesizeSpeechCommand,
  OutputFormat,
  Engine,
  VoiceId,
  LanguageCode,
} from '@aws-sdk/client-polly';

import { PutObjectCommand, S3Client } from '@aws-sdk/client-s3';
import { Readable } from 'stream';

// Helper function to convert stream to buffer
async function streamToBuffer(stream: Readable): Promise<Buffer> {
  return new Promise<Buffer>((resolve, reject) => {
    const chunks: Buffer[] = [];
    stream.on('data', (chunk) =>
      chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk))
    );
    stream.on('error', reject);
    stream.on('end', () => resolve(Buffer.concat(chunks)));
  });
}

// Initialize clients
const polly = new PollyClient({});
const s3 = new S3Client({});

interface ConvertToSpeechRequest {
  fileKey: string;
  formattedText?: string;
  translatedText?: string;
  targetLanguage?: string;
}

// Voice mapping for different languages
const voiceMap: Record<
  string,
  { voiceId: VoiceId; languageCode: LanguageCode }
> = {
  english: { voiceId: 'Matthew', languageCode: 'en-US' },
  french: { voiceId: 'Mathieu', languageCode: 'fr-FR' },
  spanish: { voiceId: 'Miguel', languageCode: 'es-ES' },
  german: { voiceId: 'Hans', languageCode: 'de-DE' },
  italian: { voiceId: 'Giorgio', languageCode: 'it-IT' },
  portuguese: { voiceId: 'Ricardo', languageCode: 'pt-PT' },
  japanese: { voiceId: 'Takumi', languageCode: 'ja-JP' },
  chinese: { voiceId: 'Zhiyu', languageCode: 'cmn-CN' },
  // Add more languages as needed
};

async function textToSpeech(
  text: string,
  language: string,
  fileKey: string
): Promise<string> {
  if (!text || text.trim() === '') {
    throw new Error('No text content to convert to speech');
  }

  // Normalize language name for lookup (lowercase)
  const normalizedLang = language.toLowerCase();

  // Get voice settings from the map, default to English if not found
  const voiceSettings = voiceMap[normalizedLang] || voiceMap.english;

  // Log selected voice
  console.log(`Using voice ${voiceSettings.voiceId} for language ${language}`);

  // Generate a unique S3 key for the audio file
  const audioFileKey = `speech/${
    fileKey.split('/').pop()?.split('.')[0] || 'audio'
  }-${Date.now()}.mp3`;

  try {
    // Call Amazon Polly to synthesize speech
    const pollyResponse = await polly.send(
      new SynthesizeSpeechCommand({
        Text: text,
        OutputFormat: OutputFormat.MP3,
        VoiceId: voiceSettings.voiceId,
        LanguageCode: voiceSettings.languageCode,
        Engine: Engine.NEURAL,
      })
    );

    // Upload the audio stream to S3
    if (!pollyResponse.AudioStream) {
      throw new Error('No audio stream generated by Polly');
    }

    const bucketName = process.env.BUCKET_NAME;
    if (!bucketName) {
      throw new Error('Missing BUCKET_NAME in environment variables');
    }

    // Convert the audio stream to a buffer
    const audioBuffer = await streamToBuffer(
      pollyResponse.AudioStream as Readable
    );

    await s3.send(
      new PutObjectCommand({
        Bucket: bucketName,
        Key: audioFileKey,
        Body: audioBuffer,
        ContentType: 'audio/mpeg',
      })
    );

    console.log(`Audio file saved to S3: ${audioFileKey}`);
    return audioFileKey;
  } catch (error) {
    console.error('Error converting text to speech:', error);
    throw new Error(
      `Failed to convert text to speech: ${
        error instanceof Error ? error.message : 'Unknown error'
      }`
    );
  }
}

export const handler: Handler = async (event: ConvertToSpeechRequest) => {
  console.log(
    'Convert to speech Lambda invoked with event:',
    JSON.stringify(event)
  );

  if (!event.fileKey) {
    throw new Error('Missing fileKey in event');
  }

  // Determine which text to use for speech
  let textToConvert: string;
  let language = 'english';

  if (event.translatedText && event.targetLanguage) {
    // Use translated text if available
    textToConvert = event.translatedText;
    language = event.targetLanguage;
  } else if (event.formattedText) {
    // Otherwise use formatted text
    textToConvert = event.formattedText;
  } else {
    throw new Error('No text found to convert to speech');
  }

  // Convert text to speech and get S3 location
  const audioFileKey = await textToSpeech(
    textToConvert,
    language,
    event.fileKey
  );

  // Keep all original properties and add our result
  // This ensures doTranslate, doSpeech and other properties remain at the root level
  return {
    ...event,
    audioFileKey,
  };
};
