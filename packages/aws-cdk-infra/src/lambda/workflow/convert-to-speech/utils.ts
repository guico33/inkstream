import {
  PollyClient,
  SynthesizeSpeechCommand,
  OutputFormat,
  Engine,
} from '@aws-sdk/client-polly';
import { Readable } from 'stream';
import { generateUserS3Key, saveBinaryToS3 } from '../../../utils/s3-utils';
import { streamToBuffer } from '../../../utils/stream-utils';
import { getErrorMessage } from '../../../utils/error-utils';

export function preprocessTextForSpeech(text: string): string {
  let processedText = text;
  processedText = processedText.replace(/^(#{1,6})\s+(.+?)$/gm, '$2');
  processedText = processedText.replace(/^\s*[-*+]\s+/gm, '');
  processedText = processedText.replace(/^\s*\d+\.\s+/gm, '');
  processedText = processedText.replace(/```[\s\S]*?```/g, '');
  processedText = processedText.replace(/`([^`]+)`/g, '$1');
  return processedText;
}

export const voiceMap = {
  english: { voiceId: 'Joanna', languageCode: 'en-US', supportsNeural: true },
  french: { voiceId: 'Lea', languageCode: 'fr-FR', supportsNeural: true },
  spanish: { voiceId: 'Lupe', languageCode: 'es-US', supportsNeural: true },
  german: { voiceId: 'Vicki', languageCode: 'de-DE', supportsNeural: true },
  italian: { voiceId: 'Bianca', languageCode: 'it-IT', supportsNeural: true },
  portuguese: {
    voiceId: 'Camila',
    languageCode: 'pt-BR',
    supportsNeural: true,
  },
  japanese: { voiceId: 'Takumi', languageCode: 'ja-JP', supportsNeural: true },
  chinese: { voiceId: 'Zhiyu', languageCode: 'cmn-CN', supportsNeural: true },
} as const;

export async function textToSpeech(
  polly: PollyClient,
  text: string,
  language: string,
  fileKey: string,
  outputBucket: string,
  userId: string
): Promise<{ bucket: string; key: string }> {
  if (!text || text.trim() === '') {
    throw new Error('No text content to convert to speech');
  }
  const normalizedLang = language.toLowerCase();
  const voiceSettings =
    normalizedLang in voiceMap
      ? voiceMap[normalizedLang as keyof typeof voiceMap]
      : voiceMap.english;
  const audioFileKey = generateUserS3Key(
    userId,
    'speech',
    fileKey,
    'mp3',
    `${language.toLowerCase()}-${Date.now()}`
  );
  try {
    const processedText = preprocessTextForSpeech(text);
    const pollyResponse = await polly.send(
      new SynthesizeSpeechCommand({
        Text: processedText,
        OutputFormat: OutputFormat.MP3,
        VoiceId: voiceSettings.voiceId,
        LanguageCode: voiceSettings.languageCode,
        Engine: voiceSettings.supportsNeural ? Engine.NEURAL : Engine.STANDARD,
      })
    );
    if (!pollyResponse.AudioStream) {
      throw new Error('No audio stream generated by Polly');
    }
    const audioBuffer = await streamToBuffer(
      pollyResponse.AudioStream as Readable
    );
    const s3Path = await saveBinaryToS3(
      outputBucket,
      audioFileKey,
      audioBuffer,
      'audio/mpeg'
    );
    return s3Path;
  } catch (error) {
    throw new Error(
      `Failed to convert text to speech: ${getErrorMessage(error)}`
    );
  }
}
