import { describe, it, expect, vi, beforeEach } from 'vitest';
import { PollyClient } from '@aws-sdk/client-polly';
import { preprocessTextForSpeech, voiceMap, textToSpeech } from './utils';
import * as s3Utils from '../../../utils/s3-utils';
import * as streamUtils from '../../../utils/stream-utils';
import * as errorUtils from '../../../utils/error-utils';

vi.mock('../../../utils/s3-utils');
vi.mock('../../../utils/stream-utils');
vi.mock('../../../utils/error-utils');

const mockedS3Utils = vi.mocked(s3Utils);
const mockedStreamUtils = vi.mocked(streamUtils);
const mockedErrorUtils = vi.mocked(errorUtils);

const mockPolly = {
  send: vi.fn(),
} as unknown as PollyClient;

describe('preprocessTextForSpeech', () => {
  it('removes markdown headings', () => {
    expect(preprocessTextForSpeech('# Heading')).toBe('Heading');
    expect(preprocessTextForSpeech('## Subheading')).toBe('Subheading');
  });
  it('removes bullet points and numbered lists', () => {
    expect(preprocessTextForSpeech('- bullet')).toBe('bullet');
    expect(preprocessTextForSpeech('1. numbered')).toBe('numbered');
  });
  it('removes code blocks and inline code', () => {
    expect(preprocessTextForSpeech('```code```')).toBe('');
    expect(preprocessTextForSpeech('`inline`')).toBe('inline');
  });
  it('returns plain text unchanged', () => {
    expect(preprocessTextForSpeech('plain text')).toBe('plain text');
  });
});

describe('voiceMap', () => {
  it('contains expected languages and settings', () => {
    expect(voiceMap.english.voiceId).toBe('Joanna');
    expect(voiceMap.french.languageCode).toBe('fr-FR');
    expect(voiceMap.japanese.supportsNeural).toBe(true);
  });
});

describe('textToSpeech', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    mockedS3Utils.generateUserS3Key.mockReturnValue('user/speech/file.mp3');
    mockedStreamUtils.streamToBuffer.mockResolvedValue(Buffer.from('audio'));
    mockedS3Utils.saveBinaryToS3.mockResolvedValue({
      bucket: 'bucket',
      key: 'user/speech/file.mp3',
    });
    mockedErrorUtils.getErrorMessage.mockImplementation(
      (e: any) => e?.message || String(e)
    );
  });

  it('throws if text is empty', async () => {
    await expect(
      textToSpeech(mockPolly, '', 'english', 'file.txt', 'bucket', 'user')
    ).rejects.toThrow('No text content to convert to speech');
  });

  it('uses correct voice settings for language', async () => {
    mockPolly.send = vi.fn().mockResolvedValue({ AudioStream: 'stream' });
    await textToSpeech(
      mockPolly,
      'hello',
      'french',
      'file.txt',
      'bucket',
      'user'
    );
    const callArg = (mockPolly.send as any).mock.calls[0][0];
    expect(callArg.input).toMatchObject({
      VoiceId: 'Lea',
      LanguageCode: 'fr-FR',
    });
  });

  it('defaults to English voice if language not found', async () => {
    mockPolly.send = vi.fn().mockResolvedValue({ AudioStream: 'stream' });
    await textToSpeech(
      mockPolly,
      'hello',
      'unknown',
      'file.txt',
      'bucket',
      'user'
    );
    const callArg = (mockPolly.send as any).mock.calls[0][0];
    expect(callArg.input).toMatchObject({
      VoiceId: 'Joanna',
      LanguageCode: 'en-US',
    });
  });

  it('throws if Polly returns no AudioStream', async () => {
    mockPolly.send = vi.fn().mockResolvedValue({});
    await expect(
      textToSpeech(mockPolly, 'hello', 'english', 'file.txt', 'bucket', 'user')
    ).rejects.toThrow('No audio stream generated by Polly');
  });

  it('returns S3 path on success', async () => {
    mockPolly.send = vi.fn().mockResolvedValue({ AudioStream: 'stream' });
    const result = await textToSpeech(
      mockPolly,
      'hello',
      'english',
      'file.txt',
      'bucket',
      'user'
    );
    expect(result).toEqual({ bucket: 'bucket', key: 'user/speech/file.mp3' });
    expect(mockedS3Utils.saveBinaryToS3).toHaveBeenCalledWith(
      'bucket',
      'user/speech/file.mp3',
      expect.any(Buffer),
      'audio/mpeg'
    );
  });

  it('throws with error message if Polly or S3 fails', async () => {
    mockPolly.send = vi.fn().mockRejectedValue(new Error('fail polly'));
    await expect(
      textToSpeech(mockPolly, 'hello', 'english', 'file.txt', 'bucket', 'user')
    ).rejects.toThrow('Failed to convert text to speech: fail polly');
  });
});
