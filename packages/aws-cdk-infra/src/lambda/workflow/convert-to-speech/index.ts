import { Handler } from 'aws-lambda';
import {
  PollyClient,
  SynthesizeSpeechCommand,
  OutputFormat,
  Engine,
} from '@aws-sdk/client-polly';
import { Readable } from 'stream';

// Import utility functions
import {
  getTextFromS3,
  generateUserS3Key,
  saveBinaryToS3,
} from '../../../utils/s3-utils';
import { streamToBuffer } from '../../../utils/stream-utils';
import {
  createS3Response,
  createS3ErrorResponse,
} from '../../../utils/response-utils';
import {
  formatErrorForLogging,
  getErrorMessage,
} from '../../../utils/error-utils';

// Initialize Polly client
const polly = new PollyClient({});

interface ConvertToSpeechRequest {
  fileKey: string;
  formattedTextS3Path?: { bucket: string; key: string };
  translatedTextS3Path?: { bucket: string; key: string };
  outputBucket: string;
  textToSpeak?: string; // Allow direct text input
  targetLanguage?: string;
  workflowId?: string;
  userId: string; // Added for user-specific S3 paths
}

/**
 * Preprocesses text to remove Markdown formatting that would
 * affect the speech output quality when using Amazon Polly.
 */
function preprocessTextForSpeech(text: string): string {
  let processedText = text;

  // Replace Markdown headings with just the text
  // This removes heading markers like # ## ###, etc.
  processedText = processedText.replace(/^(#{1,6})\s+(.+?)$/gm, '$2');

  // Additional preprocessing for other Markdown elements
  // Remove bullet points
  processedText = processedText.replace(/^\s*[-*+]\s+/gm, '');
  // Remove numbered lists markers
  processedText = processedText.replace(/^\s*\d+\.\s+/gm, '');
  // Remove code block markers
  processedText = processedText.replace(/```[\s\S]*?```/g, '');
  // Remove inline code marks
  processedText = processedText.replace(/`([^`]+)`/g, '$1');

  console.log('Text preprocessed for Polly - removed Markdown formatting');
  return processedText;
}

// Voice mapping for different languages
const voiceMap = {
  english: { voiceId: 'Joanna', languageCode: 'en-US', supportsNeural: true },
  french: { voiceId: 'Lea', languageCode: 'fr-FR', supportsNeural: true },
  spanish: { voiceId: 'Lupe', languageCode: 'es-US', supportsNeural: true },
  german: { voiceId: 'Vicki', languageCode: 'de-DE', supportsNeural: true },
  italian: { voiceId: 'Bianca', languageCode: 'it-IT', supportsNeural: true },
  portuguese: {
    voiceId: 'Camila',
    languageCode: 'pt-BR',
    supportsNeural: true,
  },
  japanese: { voiceId: 'Takumi', languageCode: 'ja-JP', supportsNeural: true },
  chinese: { voiceId: 'Zhiyu', languageCode: 'cmn-CN', supportsNeural: true },
  // Add more languages as needed
} as const;

async function textToSpeech(
  text: string,
  language: string,
  fileKey: string,
  outputBucket: string,
  userId: string
): Promise<{ bucket: string; key: string }> {
  if (!text || text.trim() === '') {
    throw new Error('No text content to convert to speech');
  }

  const normalizedLang = language.toLowerCase();
  const voiceSettings =
    normalizedLang in voiceMap
      ? voiceMap[normalizedLang as keyof typeof voiceMap]
      : voiceMap.english; // Default to English if not found

  console.log(`Using voice ${voiceSettings.voiceId} for language ${language}`);

  // Generate a user-specific S3 key for the audio file
  const audioFileKey = generateUserS3Key(
    userId,
    'speech',
    fileKey,
    'mp3',
    `${language.toLowerCase()}-${Date.now()}`
  );

  try {
    const processedText = preprocessTextForSpeech(text);
    const pollyResponse = await polly.send(
      new SynthesizeSpeechCommand({
        Text: processedText,
        OutputFormat: OutputFormat.MP3,
        VoiceId: voiceSettings.voiceId,
        LanguageCode: voiceSettings.languageCode,
        Engine: voiceSettings.supportsNeural ? Engine.NEURAL : Engine.STANDARD,
      })
    );

    if (!pollyResponse.AudioStream) {
      throw new Error('No audio stream generated by Polly');
    }

    const audioBuffer = await streamToBuffer(
      pollyResponse.AudioStream as Readable
    );

    // Save the audio file to S3
    const s3Path = await saveBinaryToS3(
      outputBucket,
      audioFileKey,
      audioBuffer,
      'audio/mpeg'
    );

    console.log(`Audio file saved to S3: s3://${s3Path.bucket}/${s3Path.key}`);
    return s3Path;
  } catch (error) {
    console.error(
      'Error converting text to speech:',
      formatErrorForLogging('text to speech conversion', error)
    );
    throw new Error(
      `Failed to convert text to speech: ${getErrorMessage(error)}`
    );
  }
}

export const handler: Handler = async (event: ConvertToSpeechRequest) => {
  console.log(
    'ConvertToSpeech Lambda invoked with event:',
    JSON.stringify(event, null, 2)
  );

  let textForSpeech: string | undefined = undefined;
  let sourceLanguage = event.targetLanguage || 'english';

  // Always fetch text from S3, preferring translated text, then formatted text
  if (event.translatedTextS3Path?.bucket && event.translatedTextS3Path?.key) {
    try {
      console.log(
        `Fetching translated text from S3: s3://${event.translatedTextS3Path.bucket}/${event.translatedTextS3Path.key}`
      );
      textForSpeech = await getTextFromS3(
        event.translatedTextS3Path.bucket,
        event.translatedTextS3Path.key
      );
      sourceLanguage = event.targetLanguage || 'english';
    } catch (error) {
      console.error(
        'Error fetching translated text from S3:',
        formatErrorForLogging('S3 fetch', error)
      );
      const errorResponse = createS3ErrorResponse(
        500,
        'Error fetching translated text from S3',
        error
      );
      return {
        ...event,
        ...errorResponse,
        speechError: `Failed to fetch translated text: ${getErrorMessage(
          error
        )}`,
      };
    }
  } else if (
    event.formattedTextS3Path?.bucket &&
    event.formattedTextS3Path?.key
  ) {
    try {
      console.log(
        `Fetching formatted text from S3: s3://${event.formattedTextS3Path.bucket}/${event.formattedTextS3Path.key}`
      );
      textForSpeech = await getTextFromS3(
        event.formattedTextS3Path.bucket,
        event.formattedTextS3Path.key
      );
      sourceLanguage = 'english';
    } catch (error) {
      console.error(
        'Error fetching formatted text from S3:',
        formatErrorForLogging('S3 fetch', error)
      );
      const errorResponse = createS3ErrorResponse(
        500,
        'Error fetching formatted text from S3',
        error
      );
      return {
        ...event,
        ...errorResponse,
        speechError: `Failed to fetch formatted text: ${getErrorMessage(
          error
        )}`,
      };
    }
  }

  // If neither S3 path is present or fetch failed, error out (legacy direct text input is no longer supported)
  if (!textForSpeech) {
    console.error(
      'No S3 text path provided or failed to fetch text for speech synthesis.'
    );
    const errorResponse = createS3ErrorResponse(
      400,
      'No text content for speech synthesis'
    );
    return {
      ...event,
      ...errorResponse,
      speechError: 'No text content provided',
    };
  }

  if (!event.outputBucket) {
    console.error('Output bucket not specified.');
    const errorResponse = createS3ErrorResponse(
      500,
      'Output bucket not configured'
    );
    return {
      ...event,
      ...errorResponse,
      speechError: 'Output bucket not configured',
    };
  }

  try {
    const s3Path = await textToSpeech(
      textForSpeech,
      sourceLanguage,
      event.fileKey,
      event.outputBucket,
      event.userId || 'unknown-user'
    );

    const response = createS3Response(
      s3Path,
      'Speech synthesized and saved successfully.',
      { sourceLanguage }
    );

    return {
      ...event,
      ...response,
      speechS3Path: s3Path, // For backward compatibility
    };
  } catch (error: unknown) {
    console.error(
      'Error in speech synthesis handler:',
      formatErrorForLogging('speech synthesis handler', error)
    );

    const errorResponse = createS3ErrorResponse(
      500,
      'Error processing speech synthesis',
      error
    );

    return {
      ...event,
      ...errorResponse,
      speechError: getErrorMessage(error),
    };
  }
};
